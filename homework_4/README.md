# ДЗ №4

Реализация логгера и кастомного приёмника данных

## Задание

### Логгер

Есть интерфейс логгера, через который код, использующий логгер, связывается с реализацией логгера:

```go
type Logger interface {
  Debug(args ...any)
  Debugf(format string, args ...any)
  Print(args ...any)
  Printf(format string, args ...any)
  Error(args ...any)
  Errorf(format string, args ...any)
  SetOutput(writer io.Writer)
  SetDebugMode(debugMode bool)
}
```

Необходимо реализовать интерфейс Logger в пакете logger

Каждая функция вывода (первые 6 в интерфейсе) должна обладать поведением, аналогичным, соответственно, `fmt.Fprintln` и `fmt.Fprintf` (эти функции должны вызываться из функций, реализованных вами, т.е. вы реализуете обёртку над `Fprint*` функциями)

Предпоследняя функция (`SetOutput`) должна устанавливать направление вывода информации для первых 6-ти функций интерфейса `Logger`

Последняя функция (`SetDebugMode`) должна переключать флаг `debugMode`: если `debugMode == true`, то `Debug` и `Debugf` выводят лог-сообщения, иначе они ничего не делают

`Debug` и `Debugf` должны выводить свои сообщения в заданную `SetOutput` цель с меткой **[DEBUG]** перед сообщением, когда `debugMode == true`:

```plain
[DEBUG] log message
```

, иначе `Debug` и `Debugf` ничего не делают

`Print` и `Printf` должны выводить свои сообщения всегда, при этом если `debugMode == true`, то, аналогично `Debug` и `Debugf`, добавляется метка **[DEBUG]**

`Error` и `Errorf` должны выводить свои сообщения при любом вызове, добавляя перед сообщением метку **[ERROR]**, при этом если `debugMode == true`, то, аналогично `Debug` и `Debugf`, также добавляется метка **[DEBUG]**. Возможна такая ситуация при вызове `Error` или `Errorf`:

```plain
[DEBUG] [ERROR] log message
```

#### Пример использования для понимания структуры логгера

- Создаётся новый объект логгера
- С помощью `SetOutput` устанавливается место, куда будут выводиться логи (терминал, файл и т.д.)
- С помощью `SetDebugMode` *выключается* дебаг-режим
- Выводятся логи, кроме вызовов функций `Debug` и `Debugf`
- С помощью `SetOutput` изменяется место вывода логов
- Логи теперь выводятся в новое место
- С помощью `SetDebugMode` *включается* дебаг-режим
- Логи продолжают выводиться в цель, а так же выводятся `Debug` или `Debugf`

### Кастомный приёмник данных

В Go есть несколько интерфейсов, которые облегчают жизнь разработчиков - они стандартизируют код и позволяют связывать пакеты, связь которых не была заранее известна. Примером такого интерфейса является io.Writer:

```go
type Writer interface {
  Write(p []byte) (n int, err error)
}
```

Используя этот интерфейс, можно писать универсальный код, который позволяет записывать (`Write`) что-либо (слайс байтов) куда-угодно (зависит от реализации интерфейса). Этот интерфейс используется `fmt.Fprint*` функциями, позволяя записывать текст и в терминал, и в файл, и в сеть, и куда-угодно.

Требуется написать очередную реализацию интерфейса Writer в пакете writer :)

Для этого в структуре `customWriter` нужно реализовать метод `Write`, который будет выводить в терминал с помощью `fmt.Println` передаваемый слайс байтов в виде строки (*type conversion*, `string(p)`) после метки **[CUSTOM WRITER]**. `Write` должен возвращать длину переданного слайса байтов (`len(p)`) и нулевую ошибку (`nil`). Планируется совместное использование с логгером, поэтому сообщения могут выводиться таким образом:

```plain
[CUSTOM WRITER] log message
[CUSTOM WRITER] [DEBUG] log message
[CUSTOM WRITER] [DEBUG] [ERROR] log message
```
